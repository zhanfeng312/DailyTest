闵卫
minwei@tarena.com.cn
一、C++语言语法基础(6)
1.从C到C++的过渡(1)
2.类和对象(2)
3.操作符重载(1)
4.继承与多态(1)
5.异常和I/O流(1)
二、数据结构和算法(3)
1.基本数据结构，堆栈、队列、链表、二叉树，实现和应用(2)
2.排序和查找算法(1)
三、模板和STL(3)
1.模板语法(1)
2.STL(2)
四、阶段项目(2)
简化的企业管理信息系统(MIS)
第一课 从C到C++的过渡
一、背景介绍
算盘 - 面向硬件的编程
电子计算机 - 机器语言的编程1010
           - 汇编语言的编程ADD
           - 高级语言的编程Fortran
             printf ("%d", 12);
           - 结构化程序设计C/PASCL
             顺序、分支、循环、函数
           - 面向对象的程序设计C++/Java/C#
           - 面向问题的程序设计
1960 - Algol 60，算法语言,远离硬件，不适合进行系统开发
1963 - 剑桥大学，CPL，在Algol 60的基础上增加对系统开发的支持，复杂，不易掌握，不易使用
1970 - MIT，BCPL，CPL的精华版，易学易用，太慢，不实用
1972 - Ken Thomposon，B语言，通过运行时支持优化BCPL的性能，缺少类型
1973 - Dennis Ritchie，C语言，用C重新实现UNIX内核
1978 - 《The C Programming Language》，第一个C语言的事实标准
1989 - ANSI C，C89
1990 - ISO C, C90
1999 - ISO C 修订，C99
197X - Bajarne Stroustrup，simula早期的面向对象语言，性能低下，B语言。
1979 - 贝尔实验室，多核UNIX系统仿真，Cpre，
通过扩展宏为C语言增加类似simula的面向对象机制。C with Class:
simula - 类
Alogo 68 - 操作符重载
Ada - 模板、名字空间
Smalltalk - 引用、异常
C是C++的子集，C++是对C的扩展。
1983 - C++命名
1985 - CFront 1.0，第一款商用C++编译器
1987 - GNU C++
1990 - Borland C++
1992 - Microsoft C++，IBM C++
1998 - ISO C++98
2003 - ISO C++03
2011 - ISO C++2011/C++11/C++0x
二、C++语言的使用领域：
1.游戏开发：强建模能力，性能高。
2.科学计算：FORTRAN，C++算法库。
3.网络和分布式：ACE框架。
4.桌面应用：VC/MFC，Office，QQ，多媒体
5.操作系统和设备驱动：优化编译器的发明使C++在底层开发方面可以和C向媲美。
6.移动终端
既需要性能，同时又要有面向对象的建模。
三、C++比C更丰富
1.支持面向对象，将问题域和方法域统一化。宏观面向对象，微观面向过程。
2.支持泛型编程。
int add (int a, int b) { ... }
template<typename T>
T add (T a, T b) { ... }
3.支持异常机制。
int func (void) {
  ...
}
int main (void) {
  if (func () == -1) {
     错误处理;
  }
}
4.操作符重载
四、第一个C++程序
1.编译器：g++，如果用gcc需要带上-lstdc++，
指定其使用标准c++的运行库。

2.源文件扩展名：.cpp/.cc/.C/.cxx/.c++，最好用.cpp

3.头文件：#include <iostream>
大多数标准库头文件都没有.h后缀。

4.输出：cout - 标准输出对象
  输入：cin  - 标准输入对象
  插入运算符：<<
  提取运算符：>>

5.std：所有标准库的函数、对象、类型都位于std名字空间中。

五、名字空间

1.对程序中的标识符（类型、函数、变量）,
按照某种逻辑规则划分成若干组。

2.定义名字空间
namespace 名字空间名 {
  名字空间成员;
}

3.使用名字空间

1)作用于限定符：名字空间名::名字空间成员，
表示访问特定名字空间中的特定成员。

2)名字空间指令：
using namespace 名字空间名;
在该条指令之后的代码对指令所指名字空间中的所有成员都可见，
可直接访问这些成员，无需加“::”。

3)名字空间声明：
using 名字空间名::名字空间成员;
将指定名字空间中的某个成员引入当前作用域，
可直接访问这些成员，无需加“::”。

4.匿名名字空间
如果一个标识符没有被显示地定义在任何名字空间中，
编译器会将其缺省地置于匿名名字空间中。
对匿名名字空间中的成员通过“::名字空间成员”的形式访问。

5.名字空间合并

6.名字空间嵌套
namespace ns1 {
  namespace ns2 {
    namespace ns3 {
      void foo (void) { ... }
    }
  }
}
ns1::ns2::ns3::foo ();
using namespace ns1::ns2::ns3;

foo ();
六、C++中的结构、联合和枚举

1.结构
 和C语言的不同：
1)定义结构型变量时，可以省略struct关键字。
2)结构内部可以定义函数——成员函数。
3)sizeof (空结构) -> 1

2.联合
增加了匿名联合的概念。借用联合语法形式，
描述一些变量在内存中的布局方式。
int main()
{
	UNION 
	{
   	int a;
   	char ch[4];
	};
 	a=0x12345678;
}
定义联合变量时，可以不加union
3.枚举
枚举是一个独立的数据类型。
C:
enum E {a, b, c};
enum E e;
e = a;
e = 1000;
C++:
enum E {a, b, c};
E e;
e = a;
e = b;
e = c;
b=1;//error
e = 1000; // ERROR !
e = 1; // ERROR !

七、C++的布尔类型，跟在cout后面可以boolalpha
bool b = true;
b = false;
cout << sizeof (b) << endl; // 1
b = 100;
b = 1.234;
b = "hello";
b = 'A';

八、C++中的运算符别名
&& - and
|| - or
&  - bitand   
^  - xor
{  - <%  
}  - %>
[  - <:
]  - :>

九、C++中的函数
1.重载：条件
	在同一个作用域中，
	函数名相同，
	参数表不同的函数，
	构成重载关系。

C++编译器会对程序中的函数做换名，
将参数表中的类型信息汇合到函数名中，以保证函数名的唯一.(这点得注意)

通过extern "C"，可以要求编译器不做C++换名，
以方便在C语言的模块中使用C++编译生成的代码。

2.缺省参数和哑元参数
1)如果调用一个函数时，没有提供实参，那么对应形参就去缺省值。
2)如果一个参数带有缺省值，那么它后边的所有参数必须都带有缺省值。
3)如果一个函数声明和定义分开，那么缺省参数只能放在声明中。
4)避免和重载发生歧义。
5)只有类型而没有名字的形参，谓之哑元。
i++ - operator++
++i
V1: void decode (int arg) { ... }
V2: void decode (int) { ... }
